"""violin plot code."""

import warnings
from copy import copy
from importlib import import_module

import arviz_stats  # pylint: disable=unused-import
import xarray as xr
from arviz_base import rcParams
from arviz_base.labels import BaseLabeller

from arviz_plots.plot_collection import PlotCollection, process_facet_dims
from arviz_plots.plots.utils import filter_aes, process_group_variables_coords
from arviz_plots.visuals import (
    labelled_title,
    line_xy,
    line_y,
    point_estimate_text,
    remove_axis,
    scatter_y,
)


def plot_violin(
    dt,
    var_names=None,
    filter_vars=None,
    group="posterior",
    coords=None,
    sample_dims=None,
    point_estimate=None,
    ci_kind=None,
    ci_prob=None,
    plot_collection=None,
    backend=None,
    labeller=None,
    aes_map=None,
    plot_kwargs=None,
    stats_kwargs=None,
    pc_kwargs=None,
):
    """Plot 1D marginal densities as violin plots.

    Generate :term:`facetted` :term:`plots` with: with violin plots to represent 1D marginal
    distributions, along with credible intervals and a point estimate.

    Parameters
    ----------
    dt : DataTree or dict of {str : DataTree}
        Input data. In case of dictionary input, the keys are taken to be model names.
        In such cases, a dimension "model" is generated and can be used to map to aesthetics.
    var_names : str or list of str, optional
        One or more variables to be plotted.
        Prefix the variables by ~ when you want to exclude them from the plot.
    filter_vars : {None, “like”, “regex”}, default=None
        If None, interpret var_names as the real variables names.
        If “like”, interpret var_names as substrings of the real variables names.
        If “regex”, interpret var_names as regular expressions on the real variables names.
    group : str, default "posterior"
        Group to be plotted.
    coords : dict, optional
    sample_dims : str or sequence of hashable, optional
        Dimensions to reduce unless mapped to an aesthetic.
        Defaults to ``rcParams["data.sample_dims"]``
    point_estimate : {"mean", "median", "mode"}, optional
        Which point estimate to plot. Defaults to rcParam :data:`stats.point_estimate`
    ci_kind : {"eti", "hdi"}, optional
        Which credible interval to use. Defaults to ``rcParams["stats.ci_kind"]``
    ci_prob : float, optional
        Indicates the probability that should be contained within the plotted credible interval.
        Defaults to ``rcParams["stats.ci_prob"]``
    plot_collection : PlotCollection, optional
    backend : {"matplotlib", "bokeh"}, optional
    labeller : labeller, optional
    aes_map : mapping of {str : sequence of str}, optional
        Mapping of artists to aesthetics that should use their mapping in `plot_collection`
        when plotted. Valid keys are the same as for `plot_kwargs`.

        With a single model, no aesthetic mappings are generated by default,
        each variable+coord combination gets a :term:`plot` but they all look the same,
        unless there are user provided aesthetic mappings.
        With multiple models, ``plot_dist`` maps "color" and "x" to the "model" dimension.

        By default, all aesthetics but "x" are mapped to the density representation,
        and if multiple models are present, "color" and "x" are mapped to the
        credible interval and the point estimate.

        When "point_estimate" key is provided but "point_estimate_text" isn't,
        the values assigned to the first are also used for the second.
    plot_kwargs : mapping of {str : mapping or False}, optional
        Valid keys are:

        * left_density -> passed to :func:`~arviz_plots.visuals.line_xy`
        * right_density -> passed to :func:`~arviz_plots.visuals.line_xy`
        * credible_interval -> passed to :func:`~arviz_plots.visuals.line_x`
        * point_estimate -> passed to :func:`~arviz_plots.visuals.scatter_x`
        * point_estimate_text -> passed to :func:`~arviz_plots.visuals.point_estimate_text`
        * title -> passed to :func:`~arviz_plots.visuals.labelled_title`
        * remove_axis -> not passed anywhere, can only be ``False`` to skip calling this function

    stats_kwargs : mapping, optional
        Valid keys are:

        * left_density -> passed to kde
        * right_density -> passed to kde
        * credible_interval -> passed to eti or hdi
        * point_estimate -> passed to mean, median or mode

    pc_kwargs : mapping
        Passed to :class:`arviz_plots.PlotCollection.wrap`

    Returns
    -------
    PlotCollection

    See Also
    --------
    :ref:`plots_intro` :
        General introduction to batteries-included plotting functions, common use and logic overview

    Examples
    --------
    Map the color to the variable, and have the mapping apply
    to the title too instead of only the density representation:

    .. plot::
        :context: close-figs

        >>> from arviz_plots import plot_violin, style
        >>> style.use("arviz-clean")
        >>> from arviz_base import load_arviz_data
        >>> non_centered = load_arviz_data('non_centered_eight')
        >>> pc = plot_violin(
        >>>     non_centered,
        >>>     coords={"school": ["Choate", "Deerfield", "Hotchkiss"]},
        >>>     pc_kwargs={"aes": {"color": ["__variable__"]}},
        >>>     aes_map={"title": ["color"]},
        >>> )

    .. minigallery:: plot_violin

    """
    if ci_kind not in ("hdi", "eti", None):
        raise ValueError("ci_kind must be either 'hdi' or 'eti'")

    if sample_dims is None:
        sample_dims = rcParams["data.sample_dims"]
    if isinstance(sample_dims, str):
        sample_dims = [sample_dims]
    if ci_prob is None:
        ci_prob = rcParams["stats.ci_prob"]
    if ci_kind is None:
        ci_kind = rcParams["stats.ci_kind"] if "stats.ci_kind" in rcParams else "eti"
    if point_estimate is None:
        point_estimate = rcParams["stats.point_estimate"]
    if plot_kwargs is None:
        plot_kwargs = {}
    if pc_kwargs is None:
        pc_kwargs = {}
    else:
        pc_kwargs = pc_kwargs.copy()

    if stats_kwargs is None:
        stats_kwargs = {}

    distribution = process_group_variables_coords(
        dt, group=group, var_names=var_names, filter_vars=filter_vars, coords=coords
    )
    if backend is None:
        if plot_collection is None:
            backend = rcParams["plot.backend"]
        else:
            backend = plot_collection.backend
    plot_bknd = import_module(f".backend.{backend}", package="arviz_plots")

    if plot_collection is None:
        if backend is None:
            backend = rcParams["plot.backend"]
        pc_kwargs.setdefault("col_wrap", 5)
        pc_kwargs.setdefault(
            "cols",
            ["__variable__"]
            + [dim for dim in distribution.dims if dim not in {"model"}.union(sample_dims)],
        )
        if "model" in distribution:
            pc_kwargs["aes"] = pc_kwargs.get("aes", {}).copy()
            pc_kwargs["aes"].setdefault("color", ["model"])
            pc_kwargs["aes"].setdefault("x", ["model"])

        pc_kwargs["plot_grid_kws"] = pc_kwargs.get("plot_grid_kws", {}).copy()
        figsize = pc_kwargs["plot_grid_kws"].get("figsize", None)
        figsize_units = pc_kwargs["plot_grid_kws"].get("figsize_units", "inches")
        if figsize is None:
            num_plots = process_facet_dims(distribution, pc_kwargs["cols"])[0]
            if num_plots < pc_kwargs["col_wrap"]:
                cols = num_plots
                rows = 1
            else:
                cols = pc_kwargs["col_wrap"]
                rows = num_plots // cols + 1
            figsize = plot_bknd.scale_fig_size(
                figsize,
                rows=rows,
                cols=cols,
                figsize_units=figsize_units,
            )
            figsize_units = "dots"
        pc_kwargs["plot_grid_kws"]["figsize"] = figsize
        pc_kwargs["plot_grid_kws"]["figsize_units"] = figsize_units
        plot_collection = PlotCollection.wrap(
            distribution,
            backend=backend,
            **pc_kwargs,
        )

    if aes_map is None:
        aes_map = {}
    else:
        aes_map = aes_map.copy()
    aes_map.setdefault("left_density", plot_collection.aes_set.difference("x"))
    aes_map.setdefault("right_density", plot_collection.aes_set.difference("x"))
    if "model" in distribution:
        aes_map.setdefault("credible_interval", ["color", "x"])
        aes_map.setdefault("point_estimate", ["color", "x"])
    if "point_estimate" in aes_map and "point_estimate_text" not in aes_map:
        aes_map["point_estimate_text"] = aes_map["point_estimate"]
    if labeller is None:
        labeller = BaseLabeller()

    # density

    # different stats kwargs keys for right/left densities means things like the effect
    # of different bandwidths and stat args can be compared

    left_density_kwargs = copy(plot_kwargs.get("left_density", {}))

    if left_density_kwargs is not False:
        left_density_dims, left_density_aes, left_density_ignore = filter_aes(
            plot_collection, aes_map, "left_density", sample_dims
        )
        with warnings.catch_warnings():
            if "model" in distribution:
                warnings.filterwarnings("ignore", message="Your data appears to have a single")
            left_density = distribution.azstats.kde(
                dims=left_density_dims, **stats_kwargs.get("left_density", {})
            )

        default_color = plot_bknd.get_default_aes("color", 1, {})[0]
        if "color" not in left_density_aes:
            left_density_kwargs.setdefault("color", default_color)

        # print(f"\n density = {density!r}")

        # flip x and y coordinates
        density_flipped = left_density.rename({"plot_axis": "flipped_plot_axis"})
        density_flipped = density_flipped.assign_coords(flipped_plot_axis=["y", "x"])
        density_flipped = density_flipped.rename({"flipped_plot_axis": "plot_axis"})
        # print(f"\n flipped density = {density_flipped}")

        plot_collection.map(
            line_xy,
            "left_density",
            data=density_flipped,
            ignore_aes=left_density_ignore,
            **left_density_kwargs,
        )

    right_density_kwargs = copy(plot_kwargs.get("right_density", {}))

    if right_density_kwargs is not False:
        right_density_dims, right_density_aes, right_density_ignore = filter_aes(
            plot_collection, aes_map, "right_density", sample_dims
        )
        with warnings.catch_warnings():
            if "model" in distribution:
                warnings.filterwarnings("ignore", message="Your data appears to have a single")
            right_density = distribution.azstats.kde(
                dims=right_density_dims, **stats_kwargs.get("right_density", {})
            )

        default_color = plot_bknd.get_default_aes("color", 1, {})[0]
        if "color" not in right_density_aes:
            right_density_kwargs.setdefault("color", default_color)

        # flip x and y coordinates
        density_flipped = right_density.rename({"plot_axis": "flipped_plot_axis"})
        density_flipped = density_flipped.assign_coords(flipped_plot_axis=["y", "x"])
        density_flipped = density_flipped.rename({"flipped_plot_axis": "plot_axis"})

        plot_collection.map(
            line_xy,
            "right_density",
            data=density_flipped,
            ignore_aes=right_density_ignore,
            negative="x",
            **right_density_kwargs,
        )

    # if both left and right densities exist, take the left density as default(?)
    if left_density_kwargs is not False and right_density_kwargs is not False:
        density_kwargs = copy(plot_kwargs.get("left_density", {}))
        density = left_density
    elif left_density_kwargs is not False:
        density_kwargs = left_density_kwargs
        density = left_density
    elif right_density_kwargs is not False:
        density_kwargs = right_density_kwargs
        density = right_density
    else:
        density_kwargs = False

    if (
        (density_kwargs is not None)
        and ("model" in distribution)
        and (plot_collection.coords is None)
    ):
        reduce_dim_map = {"kde": "kde_dim", "ecdf": "quantile"}
        x_ds = plot_collection.get_aes_as_dataset("x")
        x_ds = (
            0.05
            * x_ds
            * density.sel(plot_axis="x", drop=True).max([reduce_dim_map["kde"], "model"])
        )
        plot_collection.update_aes_from_dataset("x", x_ds)

    # credible interval
    ci_kwargs = copy(plot_kwargs.get("credible_interval", {}))
    if ci_kwargs is not False:
        ci_dims, ci_aes, ci_ignore = filter_aes(
            plot_collection, aes_map, "credible_interval", sample_dims
        )
        if ci_kind == "eti":
            ci = distribution.azstats.eti(
                prob=ci_prob, dims=ci_dims, **stats_kwargs.get("credible_interval", {})
            )
        elif ci_kind == "hdi":
            ci = distribution.azstats.hdi(
                prob=ci_prob, dims=ci_dims, **stats_kwargs.get("credible_interval", {})
            )

        if "color" not in ci_aes:
            ci_kwargs.setdefault("color", "gray")
        plot_collection.map(line_y, "credible_interval", data=ci, ignore_aes=ci_ignore, **ci_kwargs)

    # point estimate
    pe_kwargs = copy(plot_kwargs.get("point_estimate", {}))
    pet_kwargs = copy(plot_kwargs.get("point_estimate_text", {}))
    if (pe_kwargs is not False) or (pet_kwargs is not False):
        pe_dims, pe_aes, pe_ignore = filter_aes(
            plot_collection, aes_map, "point_estimate", sample_dims
        )
        if point_estimate == "median":
            point = distribution.median(dim=pe_dims, **stats_kwargs.get("point_estimate", {}))
        elif point_estimate == "mean":
            point = distribution.mean(dim=pe_dims, **stats_kwargs.get("point_estimate", {}))
        else:
            raise NotImplementedError("coming soon")

    if pe_kwargs is not False:
        if "color" not in pe_aes:
            pe_kwargs.setdefault("color", "gray")
        plot_collection.map(
            scatter_y,
            "point_estimate",
            data=point,
            ignore_aes=pe_ignore,
            **pe_kwargs,
        )
    if pet_kwargs is not False:
        if density_kwargs is False:
            point_x = xr.ones_like(point)
        # elif kind == "kde":

        point_density_diff = [
            dim for dim in density.sel(plot_axis="x").dims if dim not in point.dims
        ]
        point_density_diff = ["kde_dim"] + point_density_diff
        point_x = 0.005 * density.sel(plot_axis="x", drop=True).max(dim=point_density_diff)

        point = xr.concat((point_x, point), dim="plot_axis").assign_coords(plot_axis=["x", "y"])
        _, pet_aes, pet_ignore = filter_aes(
            plot_collection, aes_map, "point_estimate_text", sample_dims
        )
        if "color" not in pet_aes:
            pet_kwargs.setdefault("color", "gray")
        pet_kwargs.setdefault("horizontal_align", "center")
        pet_kwargs.setdefault("point_label", "y")
        plot_collection.map(
            point_estimate_text,
            "point_estimate_text",
            data=point,
            point_estimate=point_estimate,
            ignore_aes=pet_ignore,
            **pet_kwargs,
        )

    # aesthetics
    title_kwargs = copy(plot_kwargs.get("title", {}))
    if title_kwargs is not False:
        _, title_aes, title_ignore = filter_aes(plot_collection, aes_map, "title", sample_dims)
        if "color" not in title_aes:
            title_kwargs.setdefault("color", "black")
        plot_collection.map(
            labelled_title,
            "title",
            ignore_aes=title_ignore,
            subset_info=True,
            labeller=labeller,
            **title_kwargs,
        )
    if plot_kwargs.get("remove_axis", True) is not False:
        plot_collection.map(
            remove_axis, store_artist=False, axis="x", ignore_aes=plot_collection.aes_set
        )

    print(f"\n pc.viz = {plot_collection.viz}")

    print(f"\n pc.aes = {plot_collection.aes}")

    return plot_collection
