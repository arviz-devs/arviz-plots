"""violin plot code."""

import warnings
from collections.abc import Mapping, Sequence
from copy import copy
from importlib import import_module
from typing import Any, Literal

import arviz_stats  # pylint: disable=unused-import
import xarray as xr
from arviz_base import rcParams
from arviz_base.labels import BaseLabeller

from arviz_plots.plot_collection import PlotCollection
from arviz_plots.plots.utils import filter_aes, process_group_variables_coords, set_wrap_layout
from arviz_plots.visuals import line_xy, line_y


def plot_violin(
    dt,
    var_names=None,
    filter_vars=None,
    group="posterior",
    coords=None,
    sample_dims=None,
    point_estimate=None,
    ci_kind=None,
    ci_prob=None,
    plot_collection=None,
    backend=None,
    labeller=None,
    aes_by_visuals: Mapping[
        Literal[
            "dist",
            "credible_interval",
            "point_estimate",
            "point_estimate_text",
            "title",
            "rug",
        ],
        Sequence[str],
    ] = None,
    visuals: Mapping[
        Literal[
            "dist",
            "credible_interval",
            "point_estimate",
            "point_estimate_text",
            "title",
            "rug",
            "remove_axis",
        ],
        Mapping[str, Any] | Literal[False],
    ] = None,
    stats: Mapping[
        Literal["dist", "credible_interval", "point_estimate"], Mapping[str, Any] | xr.Dataset
    ] = None,
    **pc_kwargs,
):
    """Plot 1D marginal densities as violin plots.

    Generate :term:`facetted` :term:`plots` with: with violin plots to represent 1D marginal
    distributions, along with credible intervals and a point estimate.

    Parameters
    ----------
    dt : DataTree or dict of {str : DataTree}
        Input data. In case of dictionary input, the keys are taken to be model names.
        In such cases, a dimension "model" is generated and can be used to map to aesthetics.
    var_names : str or list of str, optional
        One or more variables to be plotted.
        Prefix the variables by ~ when you want to exclude them from the plot.
    filter_vars : {None, “like”, “regex”}, default=None
        If None, interpret var_names as the real variables names.
        If “like”, interpret var_names as substrings of the real variables names.
        If “regex”, interpret var_names as regular expressions on the real variables names.
    group : str, default "posterior"
        Group to be plotted.
    coords : dict, optional
    sample_dims : str or sequence of hashable, optional
        Dimensions to reduce unless mapped to an aesthetic.
        Defaults to ``rcParams["data.sample_dims"]``
    point_estimate : {"mean", "median", "mode"}, optional
        Which point estimate to plot. Defaults to rcParam :data:`stats.point_estimate`
    ci_kind : {"eti", "hdi"}, optional
        Which credible interval to use. Defaults to ``rcParams["stats.ci_kind"]``
    ci_prob : float, optional
        Indicates the probability that should be contained within the plotted credible interval.
        Defaults to ``rcParams["stats.ci_prob"]``
    plot_collection : PlotCollection, optional
    backend : {"matplotlib", "bokeh"}, optional
    labeller : labeller, optional
    aes_by_visuals : mapping of {str : sequence of str}, optional
        Mapping of visuals to aesthetics that should use their mapping in `plot_collection`
        when plotted. Valid keys are the same as for `visuals`.

        With a single model, no aesthetic mappings are generated by default,
        each variable+coord combination gets a :term:`plot` but they all look the same,
        unless there are user provided aesthetic mappings.
        With multiple models, ``plot_dist`` maps "color" and "y" to the "model" dimension.

        By default, all aesthetics but "y" are mapped to the density representation,
        and if multiple models are present, "color" and "y" are mapped to the
        credible interval and the point estimate.

        When "point_estimate" key is provided but "point_estimate_text" isn't,
        the values assigned to the first are also used for the second.
    visuals : mapping of {str : mapping or False}, optional
        Valid keys are:

        * dist ->  passed to :func:`~arviz_plots.visuals.line_xy`
        * credible_interval -> passed to :func:`~arviz_plots.visuals.line_x`
        * point_estimate -> passed to :func:`~arviz_plots.visuals.scatter_x`
        * point_estimate_text -> passed to :func:`~arviz_plots.visuals.point_estimate_text`
        * title -> passed to :func:`~arviz_plots.visuals.labelled_title`
        * rug -> passed to :func:`~arviz_plots.visuals.scatter_x`. Defaults to False.
        * remove_axis -> not passed anywhere, can only be ``False`` to skip calling this function

    stats : mapping, optional
        Valid keys are:

        * dist -> passed to kde, ecdf, ...
        * credible_interval -> passed to eti or hdi
        * point_estimate -> passed to mean, median or mode

    **pc_kwargs
        Passed to :class:`arviz_plots.PlotCollection.wrap`

    Returns
    -------
    PlotCollection

    See Also
    --------
    :ref:`plots_intro` :
        General introduction to batteries-included plotting functions, common use and logic overview

    Examples
    --------
    Map the color to the variable, and have the mapping apply
    to the title too instead of only the density representation:
    .. plot::
        :context: close-figs
        >>> from arviz_plots import plot_violin, style
        >>> style.use("arviz-clean")
        >>> from arviz_base import load_arviz_data
        >>> non_centered = load_arviz_data('non_centered_eight')
        >>> pc = plot_violin(
        >>>     non_centered,
        >>>     coords={"school": ["Choate", "Deerfield", "Hotchkiss"]},
        >>> )

    .. minigallery:: plot_violin

    """
    if ci_kind not in ("hdi", "eti", None):
        raise ValueError("ci_kind must be either 'hdi' or 'eti'")

    if sample_dims is None:
        sample_dims = rcParams["data.sample_dims"]
    if isinstance(sample_dims, str):
        sample_dims = [sample_dims]
    if ci_prob is None:
        ci_prob = rcParams["stats.ci_prob"]
    if ci_kind is None:
        ci_kind = rcParams["stats.ci_kind"] if "stats.ci_kind" in rcParams else "eti"
    if point_estimate is None:
        point_estimate = rcParams["stats.point_estimate"]
    if visuals is None:
        visuals = {}
    if pc_kwargs is None:
        pc_kwargs = {}
    else:
        pc_kwargs = pc_kwargs.copy()

    if stats is None:
        stats = {}

    distribution = process_group_variables_coords(
        dt, group=group, var_names=var_names, filter_vars=filter_vars, coords=coords
    )

    if backend is None:
        if plot_collection is None:
            backend = rcParams["plot.backend"]
        else:
            backend = plot_collection.backend
    plot_bknd = import_module(f".backend.{backend}", package="arviz_plots")

    if plot_collection is None:
        if backend is None:
            backend = rcParams["plot.backend"]
        pc_kwargs["figure_kwargs"] = pc_kwargs.get("figure_kwargs", {}).copy()
        pc_kwargs.setdefault(
            "cols",
            ["__variable__"]
            + [dim for dim in distribution.dims if dim not in {"model"}.union(sample_dims)],
        )
        if "model" in distribution:
            pc_kwargs["aes"] = pc_kwargs.get("aes", {}).copy()
            pc_kwargs["aes"].setdefault("color", ["model"])
            pc_kwargs["aes"].setdefault("x", ["model"])

        pc_kwargs = set_wrap_layout(pc_kwargs, plot_bknd, distribution)
        plot_collection = PlotCollection.wrap(
            distribution,
            backend=backend,
            **pc_kwargs,
        )

    if aes_by_visuals is None:
        aes_by_visuals = {}
    else:
        aes_by_visuals = aes_by_visuals.copy()
    aes_by_visuals.setdefault("left_density", plot_collection.aes_set.difference("x"))
    aes_by_visuals.setdefault("right_density", plot_collection.aes_set.difference("x"))
    if "model" in distribution:
        aes_by_visuals.setdefault("credible_interval", ["color", "x"])
        aes_by_visuals.setdefault("point_estimate", ["color", "x"])
    if "point_estimate" in aes_by_visuals and "point_estimate_text" not in aes_by_visuals:
        aes_by_visuals["point_estimate_text"] = aes_by_visuals["point_estimate"]
    if labeller is None:
        labeller = BaseLabeller()

    # density
    left_density_kwargs = copy(visuals.get("left_density", {}))

    if left_density_kwargs is not False:
        left_density_dims, left_density_aes, left_density_ignore = filter_aes(
            plot_collection, aes_by_visuals, "left_density", sample_dims
        )
        default_color = plot_bknd.get_default_aes("color", 1, {})[0]
        if "color" not in left_density_aes:
            left_density_kwargs.setdefault("color", default_color)
        with warnings.catch_warnings():
            if "model" in distribution:
                warnings.filterwarnings("ignore", message="Your data appears to have a single")
            left_density = distribution.azstats.kde(
                dim=left_density_dims, **stats.get("left_density", {})
            )

        # flip x and y coordinates
        density_flipped = left_density.rename({"plot_axis": "flipped_plot_axis"})
        density_flipped = density_flipped.assign_coords(flipped_plot_axis=["y", "x"])
        density_flipped = density_flipped.rename({"flipped_plot_axis": "plot_axis"})

        plot_collection.map(
            line_xy,
            "left_density",
            data=density_flipped,
            ignore_aes=left_density_ignore,
            **left_density_kwargs,
        )

    right_density_kwargs = copy(visuals.get("right_density", {}))

    if right_density_kwargs is not False:
        right_density_dims, right_density_aes, right_density_ignore = filter_aes(
            plot_collection, aes_by_visuals, "right_density", sample_dims
        )
        default_color = plot_bknd.get_default_aes("color", 1, {})[0]
        if "color" not in right_density_aes:
            right_density_kwargs.setdefault("color", default_color)
        with warnings.catch_warnings():
            if "model" in distribution:
                warnings.filterwarnings("ignore", message="Your data appears to have a single")
            right_density = distribution.azstats.kde(
                dim=right_density_dims, **stats.get("right_density", {})
            )

        # flip x and y coordinates
        density_flipped = right_density.rename({"plot_axis": "flipped_plot_axis"})
        density_flipped = density_flipped.assign_coords(flipped_plot_axis=["y", "x"])
        density_flipped = density_flipped.rename({"flipped_plot_axis": "plot_axis"})

        plot_collection.map(
            line_xy,
            "right_density",
            data=density_flipped,
            ignore_aes=right_density_ignore,
            negative="x",
            **right_density_kwargs,
        )

    # if both left and right densities exist, take the left density as default(?)
    if left_density_kwargs is not False and right_density_kwargs is not False:
        density_kwargs = copy(visuals.get("left_density", {}))
        density = left_density
    elif left_density_kwargs is not False:
        density_kwargs = left_density_kwargs
        density = left_density
    elif right_density_kwargs is not False:
        density_kwargs = right_density_kwargs
        density = right_density
    else:
        density_kwargs = False

    if (
        (density_kwargs is not None)
        and ("model" in distribution)
        and (plot_collection.coords is None)
    ):
        reduce_dim_map = {"kde": "kde_dim", "ecdf": "quantile"}
        x_ds = plot_collection.get_aes_as_dataset("x")["mapping"]
        x_ds = (
            0.02
            * x_ds
            * density.sel(plot_axis="y", drop=True).max([reduce_dim_map["kde"], "model"])
        )
        plot_collection.update_aes_from_dataset("x", x_ds)

    # credible interval
    ci_kwargs = copy(visuals.get("credible_interval", {}))
    if ci_kwargs is not False:
        ci_dims, ci_aes, ci_ignore = filter_aes(
            plot_collection, aes_by_visuals, "credible_interval", sample_dims
        )
        if ci_kind == "eti":
            ci = distribution.azstats.eti(
                prob=ci_prob, dim=ci_dims, **stats.get("credible_interval", {})
            )
        elif ci_kind == "hdi":
            ci = distribution.azstats.hdi(
                prob=ci_prob, dim=ci_dims, **stats.get("credible_interval", {})
            )

        if "color" not in ci_aes:
            ci_kwargs.setdefault("color", "#4c4c4c")
        plot_collection.map(line_y, "credible_interval", data=ci, ignore_aes=ci_ignore, **ci_kwargs)

    return plot_collection
